rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a security model where user data is strictly private to the owner,
     * while shared resources like channels are accessible based on explicit membership. The rules are designed for
     * performance and security by heavily relying on denormalized data to avoid costly and complex lookups.
     *
     * Data Structure:
     * - /users/{userId}: Private user profiles, owned by the user.
     * - /channels/{channelId}: Top-level collection for chat channels. Access is controlled by a denormalized
     *   `ownerId` and a `members` map directly on each channel document.
     * - /channels/{channelId}/messages/{messageId}: Subcollection for messages, inheriting access from the parent channel.
     * - /channels/{channelId}/messages/{messageId}/attachments/{attachmentId}: Subcollection for attachments, also inheriting access.
     *
     * Key Security Decisions:
     * - User data in `/users/{userId}` is writable only by the owner. Profile data is readable by any signed-in user to
     *   facilitate social features, and listing users is allowed for search/discovery.
     * - Channel access is determined by checking the `members` map on the channel document itself. This is a deliberate
     *   denormalization strategy to make security rules fast and simple. Private channels are only visible to members,
     *   while public channels are visible to all authenticated users.
     * - Only channel owners (defined by `ownerId`) can modify channel metadata or delete the channel.
     * - Only channel members can create content (messages, attachments) within a channel.
     *
     * Denormalization for Authorization:
     * To ensure performant and secure access control, the concept of a separate `ChannelMembership` collection
     * is implemented by denormalizing a `members` map (e.g., `{ "user_abc": true, "user_xyz": true }`)
     * directly onto each `/channels/{channelId}` document. This allows rules to check membership with a single
     * document read instead of an impossible collection query.
     */

    // --------------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Returns true if the document being written to already exists.
     * Crucial for protecting against unintended writes in update/delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines owner and existence checks for robust update/delete rules.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }
    
    /**
     * Returns the data of a channel document.
     */
    function getChannel(channelId) {
      return get(/databases/$(database)/documents/channels/$(channelId)).data;
    }

    /**
     * Returns true if the user is a member of a given channel.
     * Relies on the denormalized `members` map on the channel document.
     */
    function isChannelMember(channelId) {
      // The `members` property may not exist on newly created channel docs during a create operation.
      // This check ensures that we don't try to access a null property.
      let channelData = get(/databases/$(database)/documents/channels/$(channelId)).data;
      return isSignedIn() && (
        (request.auth.uid in channelData.members) ||
        (request.auth.uid in request.resource.data.members)
      );
    }

    /**
     * Returns true if the user is the owner of a given channel.
     */
    function isChannelOwner(channelId) {
      return isSignedIn() && request.auth.uid == getChannel(channelId).ownerId;
    }

    /**
     * Returns true if a user is allowed to read a channel's content.
     * Public channels are readable by any signed-in user; private channels require membership.
     */
    function canReadChannel(channelId) {
      let channel = getChannel(channelId);
      // Use hasAll to check for the existence of the isPublic and members properties
      return isSignedIn() && (
          ('isPublic' in channel && channel.isPublic) || 
          ('members' in channel && request.auth.uid in channel.members)
      );
    }
    
    /**
     * Returns true if the user is the sender of a given message.
     */
    function isMessageSender(message) {
      return isSignedIn() && request.auth.uid == message.data.senderId;
    }

    // --------------------------------------------------------------------------
    // Collection Rules
    // --------------------------------------------------------------------------

    /**
     * @description Controls access to the users collection.
     * @path /users
     * @allow (list) An authenticated user can list users for search/invite.
     */
    match /users/{document=**} {
      allow read, write: if false;
    }

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (get) An authenticated user reading any user's profile.
     * @deny (update) An authenticated user trying to modify another user's profile.
     * @principle Allows discoverability while restricting writes to the owner.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to channel documents. Access is based on ownership and a denormalized members list.
     * @path /channels/{channelId}
     * @allow (create) An authenticated user creating a new channel, making themselves the owner and a member.
     * @deny (update) A channel member trying to change the channel's name.
     * @principle Implements shared access using a denormalized `members` map for reads and a strict `ownerId` for management.
     */
    match /channels/{channelId} {
      allow get: if canReadChannel(channelId);
      allow list: if isSignedIn(); // Allows users to see a list of channels they might join (e.g. public channels)
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid && request.auth.uid in request.resource.data.members;
      allow update: if isExistingDoc() && isChannelOwner(channelId);
      allow delete: if isExistingDoc() && isChannelOwner(channelId);
    }

    /**
     * @description Controls access to messages within a channel. Permissions are inherited from the parent channel.
     * @path /channels/{channelId}/messages/{messageId}
     * @allow (create) A member of a channel sending a new message.
     * @deny (create) A non-member trying to send a message to a private channel.
     * @principle Enforces that only members of a shared resource (the channel) can create or modify content within it.
     */
    match /channels/{channelId}/messages/{messageId} {
      allow read, list: if canReadChannel(channelId);
      allow create: if isChannelMember(channelId) && request.resource.data.senderId == request.auth.uid;
      allow update: if isExistingDoc() && isMessageSender(resource);
      allow delete: if isExistingDoc() && (isMessageSender(resource) || isChannelOwner(channelId));
    }

    /**
     * @description Controls access to message attachments. Permissions are inherited from the parent channel.
     * @path /channels/{channelId}/messages/{messageId}/attachments/{attachmentId}
     * @allow (create) A channel member adding an attachment to a message in the channel.
     * @deny (update) Any user trying to modify an existing attachment. Attachments are immutable.
     * @principle Inherits permissions from the parent container (channel) and restricts destructive actions to privileged roles (message sender, channel owner).
     */
    match /channels/{channelId}/messages/{messageId}/attachments/{attachmentId} {
      allow read, list: if canReadChannel(channelId);
      allow create: if isChannelMember(channelId) && exists(/databases/$(database)/documents/channels/$(channelId)/messages/$(messageId));
      allow update: if false;
      allow delete: if isExistingDoc() && (isMessageSender(get(/databases/$(database)/documents/channels/$(channelId)/messages/$(messageId))) || isChannelOwner(channelId));
    }
  }
}
