
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------------
    //
    // HELPER FUNCTIONS
    //
    // --------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated (signed in).
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the user is a member of a given chat.
     * This is the secure and efficient way to check for membership.
     * @param chatId The ID of the chat to check.
     */
    function isChatMember(chatId) {
      return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.members;
    }

    /**
     * Returns true if the user is the owner of a given chat.
     * @param chatId The ID of the chat to check.
     */
    function isChatOwner(chatId) {
        return isSignedIn() && request.auth.uid == get(/databases/$(database)/documents/chats/$(chatId)).data.ownerId;
    }

    // --------------------------------------------------------------------------
    //
    // COLLECTION: users
    //
    // --------------------------------------------------------------------------

    match /users/{userId} {
      /**
       * @allow (get) Any authenticated user can read another user's profile to see their name, avatar, etc.
       * @allow (create) A user can only create THEIR OWN profile.
       * @allow (update) A user can only update THEIR OWN profile, either the whole document or just presence status.
       * @allow (delete) Deleting user profiles is disallowed for safety.
       * @allow (list) This is explicitly disallowed to prevent scraping all users.
       */
      allow get: if isSignedIn();
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && (
                      request.resource.data.keys().hasAll(['id', 'email', 'username', 'userCode', 'fullName', 'createdAt', 'updatedAt']) ||
                      request.resource.data.keys().hasAll(['online', 'lastSeen']) ||
                      request.resource.data.keys().hasAll(['online'])
                    );
      allow delete: if false; 
      allow list: if false;

        // SUB-COLLECTION: chatRequests
        match /chatRequests/{requestId} {
            /**
             * @allow (read, list, update) A user can only manage their own chat requests.
             * @allow (create) Any authenticated user can create a chat request for another user.
             * @allow (delete) Users can delete requests they have received.
             */
            allow read, list, update: if isOwner(userId);
            allow create: if isSignedIn() && request.resource.data.fromUserId == request.auth.uid;
            allow delete: if isOwner(userId);
        }
    }
    
    // --------------------------------------------------------------------------
    //
    // COLLECTION: userDirectory
    //
    // --------------------------------------------------------------------------
    match /userDirectory/{userId} {
        /**
         * @allow (read, list) Any authenticated user can search the directory.
         * @allow (create) A user can only create their own directory entry.
         * @allow (update, delete) Not allowed to prevent tampering.
         */
        allow read, list: if isSignedIn();
        allow create: if isOwner(userId);
        allow update, delete: if false;
    }


    // --------------------------------------------------------------------------
    //
    // COLLECTION: chats and subcollections
    //
    // --------------------------------------------------------------------------

    match /chats/{chatId} {
      /**
       * @allow (get, update) Full read/update access is granted only to members of the chat.
       * @allow (list) Users can only list chats they are members of. This requires a `where('members', 'array-contains', request.auth.uid)` clause on the client-side query.
       * @allow (create) Any signed-in user can create a new chat, provided they include themselves as a member and the owner.
       * @allow (delete) Only the chat's designated owner can delete it.
       */
      allow get, update: if isChatMember(chatId);
      allow list: if isSignedIn() && request.query.where.to_string().contains("['members', 'array-contains', request.auth.uid]");
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.members && request.resource.data.ownerId == request.auth.uid;
      allow delete: if isChatOwner(chatId);

      // SUB-COLLECTION: messages
      match /messages/{messageId} {
        /**
         * @allow (read, list) Users can only read messages if they are a member of the parent chat.
         * @allow (create) A user can only create a message if they are a chat member, and they must be the author.
         * @allow (update) Users can only update their own messages.
         * @allow (delete) Users can delete their own messages. chat owners can also delete any message in their chat.
         */
        allow read, list: if isChatMember(chatId);
        allow create: if isChatMember(chatId) && request.resource.data.authorId == request.auth.uid;
        allow update: if isChatMember(chatId) && resource.data.authorId == request.auth.uid;
        allow delete: if isChatMember(chatId) && (resource.data.authorId == request.auth.uid || isChatOwner(chatId));
      }
    }
  }
}
